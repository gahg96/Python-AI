# 历史数据验证与模型拟合方案

## 一、核心思路

### 1.1 问题理解

在使用历史发放贷款数据验证模型时，我们需要：

1. **历史数据作为验证集**：使用历史实际发放的贷款及其结果作为验证标准
2. **模型预测对比**：将模型在当前训练数据上的预测与历史实际结果对比
3. **拟合度评估**：评估模型预测与历史结果的拟合程度
4. **校准优化**：根据拟合结果调整模型参数

### 1.2 整体流程

```
历史贷款数据（实际发放 + 实际结果）
    ↓
数据预处理和特征提取
    ↓
模型预测（使用当前训练的模型）
    ↓
对比分析（预测 vs 实际）
    ↓
拟合度评估
    ↓
模型校准和优化
```

---

## 二、历史数据准备

### 2.1 历史数据结构

```python
import pandas as pd
import numpy as np
from typing import Dict, List, Tuple

class HistoricalDataLoader:
    """历史数据加载器"""
    
    def __init__(self, data_path: str):
        self.data_path = data_path
        self.historical_data = None
    
    def load_historical_loans(self) -> pd.DataFrame:
        """
        加载历史贷款数据
        
        数据应包含：
        - 申请时的客户特征（申请时点信息）
        - 审批决策（通过/拒绝）
        - 贷款条件（金额、利率、期限）
        - 实际结果（是否违约、利润等）
        """
        df = pd.read_csv(self.data_path)
        
        # 确保数据完整性
        required_columns = [
            'customer_id',
            'application_date',
            'customer_features',  # 申请时的特征
            'expert_decision',  # 专家/历史决策
            'loan_amount',
            'interest_rate',
            'term_months',
            'actual_defaulted',  # 实际是否违约
            'actual_profit',  # 实际利润
            'actual_outcome'  # 完整结果
        ]
        
        missing_cols = [col for col in required_columns if col not in df.columns]
        if missing_cols:
            raise ValueError(f"缺少必要列: {missing_cols}")
        
        self.historical_data = df
        return df
    
    def extract_features_at_application(self, row: pd.Series) -> Dict:
        """
        提取申请时的特征（避免使用未来信息）
        
        重要：只使用申请时点可用的信息
        """
        return {
            'age': row['age'],
            'monthly_income': row['monthly_income'],
            'credit_score': row['credit_score'],
            'debt_ratio': row['debt_ratio'],
            'employment_status': row['employment_status'],
            'years_in_job': row['years_in_job'],
            # 注意：不使用申请后的信息
            # 例如：不使用 'actual_defaulted' 等
        }
    
    def prepare_validation_set(self, split_date: str = None) -> Tuple[pd.DataFrame, pd.DataFrame]:
        """
        准备验证集
        
        Args:
            split_date: 分割日期，之前的作为训练，之后的作为验证
        
        Returns:
            (train_data, validation_data)
        """
        if split_date:
            train_data = self.historical_data[
                self.historical_data['application_date'] < split_date
            ]
            validation_data = self.historical_data[
                self.historical_data['application_date'] >= split_date
            ]
        else:
            # 按时间顺序，80%训练，20%验证
            split_idx = int(len(self.historical_data) * 0.8)
            train_data = self.historical_data.iloc[:split_idx]
            validation_data = self.historical_data.iloc[split_idx:]
        
        return train_data, validation_data
```

---

## 三、模型预测与历史结果对比

### 3.1 模型预测接口

```python
class ModelPredictor:
    """模型预测器"""
    
    def __init__(self, model):
        self.model = model
    
    def predict_decision(self, customer_features: Dict) -> Dict:
        """
        预测审批决策
        
        Returns:
            {
                'decision': 'approve' or 'reject',
                'confidence': float,
                'loan_amount': float,
                'interest_rate': float,
                'term_months': int,
                'predicted_default_prob': float,
                'predicted_profit': float
            }
        """
        # 提取特征向量
        feature_vector = self.extract_feature_vector(customer_features)
        
        # 模型预测
        prediction = self.model.predict(feature_vector)
        
        return {
            'decision': prediction['decision'],
            'confidence': prediction['confidence'],
            'loan_amount': prediction.get('loan_amount', 0),
            'interest_rate': prediction.get('interest_rate', 0),
            'term_months': prediction.get('term_months', 0),
            'predicted_default_prob': prediction.get('default_probability', 0),
            'predicted_profit': prediction.get('profit', 0)
        }
    
    def batch_predict(self, customers: List[Dict]) -> List[Dict]:
        """批量预测"""
        return [self.predict_decision(customer) for customer in customers]
```

### 3.2 对比分析

```python
class HistoricalComparison:
    """历史数据对比分析"""
    
    def __init__(self, historical_data: pd.DataFrame, model_predictor: ModelPredictor):
        self.historical = historical_data
        self.predictor = model_predictor
    
    def compare_predictions(self) -> pd.DataFrame:
        """
        对比模型预测与历史实际结果
        
        Returns:
            DataFrame with columns:
            - customer_id
            - historical_decision
            - model_decision
            - decision_match
            - historical_defaulted
            - predicted_default_prob
            - historical_profit
            - predicted_profit
            - profit_diff
        """
        results = []
        
        for _, row in self.historical.iterrows():
            # 提取申请时的特征（避免未来信息泄露）
            customer_features = self.extract_features_at_application(row)
            
            # 模型预测
            prediction = self.predictor.predict_decision(customer_features)
            
            # 对比
            result = {
                'customer_id': row['customer_id'],
                'historical_decision': row['expert_decision'],
                'model_decision': prediction['decision'],
                'decision_match': row['expert_decision'] == prediction['decision'],
                'historical_defaulted': row['actual_defaulted'],
                'predicted_default_prob': prediction['predicted_default_prob'],
                'historical_profit': row['actual_profit'],
                'predicted_profit': prediction['predicted_profit'],
                'profit_diff': prediction['predicted_profit'] - row['actual_profit'],
                'loan_amount': row['loan_amount'],
                'interest_rate': row['interest_rate']
            }
            
            results.append(result)
        
        return pd.DataFrame(results)
```

---

## 四、拟合度评估

### 4.1 决策拟合度

```python
class FitEvaluator:
    """拟合度评估器"""
    
    def __init__(self, comparison_df: pd.DataFrame):
        self.comparison = comparison_df
    
    def evaluate_decision_fit(self) -> Dict:
        """
        评估决策拟合度
        
        Returns:
            {
                'overall_accuracy': float,  # 总体准确率
                'approve_accuracy': float,  # 批准决策准确率
                'reject_accuracy': float,  # 拒绝决策准确率
                'precision': float,  # 精确率
                'recall': float,  # 召回率
                'f1_score': float,  # F1分数
                'confusion_matrix': array  # 混淆矩阵
            }
        """
        from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, confusion_matrix
        
        # 只对比实际批准的案例（因为拒绝的没有实际结果）
        approved_cases = self.comparison[
            self.comparison['historical_decision'] == 'approve'
        ]
        
        if len(approved_cases) == 0:
            return {'error': 'No approved cases in historical data'}
        
        # 决策准确率
        overall_accuracy = (self.comparison['decision_match']).mean()
        
        # 批准决策准确率
        approve_accuracy = (approved_cases['decision_match']).mean()
        
        # 拒绝决策准确率
        rejected_cases = self.comparison[
            self.comparison['historical_decision'] == 'reject'
        ]
        reject_accuracy = (rejected_cases['decision_match']).mean() if len(rejected_cases) > 0 else None
        
        # 精确率、召回率、F1（针对批准决策）
        y_true = (approved_cases['historical_decision'] == 'approve').astype(int)
        y_pred = (approved_cases['model_decision'] == 'approve').astype(int)
        
        precision = precision_score(y_true, y_pred, zero_division=0)
        recall = recall_score(y_true, y_pred, zero_division=0)
        f1 = f1_score(y_true, y_pred, zero_division=0)
        
        # 混淆矩阵
        cm = confusion_matrix(y_true, y_pred)
        
        return {
            'overall_accuracy': overall_accuracy,
            'approve_accuracy': approve_accuracy,
            'reject_accuracy': reject_accuracy,
            'precision': precision,
            'recall': recall,
            'f1_score': f1,
            'confusion_matrix': cm.tolist()
        }
    
    def evaluate_default_probability_fit(self) -> Dict:
        """
        评估违约概率拟合度
        
        只针对实际批准的案例
        """
        approved_cases = self.comparison[
            self.comparison['historical_decision'] == 'approve'
        ]
        
        if len(approved_cases) == 0:
            return {'error': 'No approved cases'}
        
        # 实际违约率
        actual_default_rate = approved_cases['historical_defaulted'].mean()
        
        # 预测违约概率的平均值
        predicted_avg_default_prob = approved_cases['predicted_default_prob'].mean()
        
        # Brier Score（概率预测准确性）
        from sklearn.metrics import brier_score_loss
        brier_score = brier_score_loss(
            approved_cases['historical_defaulted'],
            approved_cases['predicted_default_prob']
        )
        
        # 校准曲线（Calibration）
        calibration_error = self.calculate_calibration_error(
            approved_cases['predicted_default_prob'],
            approved_cases['historical_defaulted']
        )
        
        # 分位数对比
        percentile_comparison = self.compare_percentiles(
            approved_cases['predicted_default_prob'],
            approved_cases['historical_defaulted']
        )
        
        return {
            'actual_default_rate': actual_default_rate,
            'predicted_avg_default_prob': predicted_avg_default_prob,
            'default_rate_diff': abs(actual_default_rate - predicted_avg_default_prob),
            'brier_score': brier_score,
            'calibration_error': calibration_error,
            'percentile_comparison': percentile_comparison
        }
    
    def calculate_calibration_error(self, predicted_probs: np.ndarray, actual_binary: np.ndarray, n_bins: int = 10) -> float:
        """
        计算校准误差
        
        将预测概率分成n_bins个区间，计算每个区间的实际违约率
        """
        bin_edges = np.linspace(0, 1, n_bins + 1)
        bin_indices = np.digitize(predicted_probs, bin_edges) - 1
        bin_indices = np.clip(bin_indices, 0, n_bins - 1)
        
        calibration_error = 0.0
        for i in range(n_bins):
            mask = bin_indices == i
            if mask.sum() > 0:
                predicted_mean = predicted_probs[mask].mean()
                actual_rate = actual_binary[mask].mean()
                calibration_error += abs(predicted_mean - actual_rate) * mask.sum()
        
        calibration_error /= len(predicted_probs)
        return calibration_error
    
    def compare_percentiles(self, predicted_probs: np.ndarray, actual_binary: np.ndarray) -> Dict:
        """对比分位数"""
        percentiles = [10, 25, 50, 75, 90, 95]
        
        comparison = {}
        for p in percentiles:
            threshold = np.percentile(predicted_probs, p)
            mask = predicted_probs <= threshold
            if mask.sum() > 0:
                predicted_rate = predicted_probs[mask].mean()
                actual_rate = actual_binary[mask].mean()
                comparison[f'p{p}'] = {
                    'threshold': threshold,
                    'predicted_rate': predicted_rate,
                    'actual_rate': actual_rate,
                    'diff': abs(predicted_rate - actual_rate)
                }
        
        return comparison
    
    def evaluate_profit_fit(self) -> Dict:
        """
        评估利润拟合度
        
        只针对实际批准的案例
        """
        approved_cases = self.comparison[
            self.comparison['historical_decision'] == 'approve'
        ]
        
        if len(approved_cases) == 0:
            return {'error': 'No approved cases'}
        
        # 实际利润统计
        actual_profit = approved_cases['historical_profit']
        predicted_profit = approved_cases['predicted_profit']
        
        # 相关性
        correlation = np.corrcoef(actual_profit, predicted_profit)[0, 1]
        
        # 平均误差
        mean_error = (predicted_profit - actual_profit).mean()
        mean_absolute_error = abs(predicted_profit - actual_profit).mean()
        mean_squared_error = ((predicted_profit - actual_profit) ** 2).mean()
        root_mean_squared_error = np.sqrt(mean_squared_error)
        
        # R²
        from sklearn.metrics import r2_score
        r2 = r2_score(actual_profit, predicted_profit)
        
        # 分位数对比
        percentiles = [10, 25, 50, 75, 90]
        actual_percentiles = np.percentile(actual_profit, percentiles)
        predicted_percentiles = np.percentile(predicted_profit, percentiles)
        
        return {
            'correlation': correlation,
            'mean_error': mean_error,
            'mean_absolute_error': mean_absolute_error,
            'root_mean_squared_error': root_mean_squared_error,
            'r2_score': r2,
            'actual_mean': actual_profit.mean(),
            'predicted_mean': predicted_profit.mean(),
            'actual_std': actual_profit.std(),
            'predicted_std': predicted_profit.std(),
            'percentile_comparison': {
                'actual': dict(zip(percentiles, actual_percentiles)),
                'predicted': dict(zip(percentiles, predicted_percentiles))
            }
        }
    
    def comprehensive_fit_evaluation(self) -> Dict:
        """综合拟合度评估"""
        return {
            'decision_fit': self.evaluate_decision_fit(),
            'default_probability_fit': self.evaluate_default_probability_fit(),
            'profit_fit': self.evaluate_profit_fit()
        }
```

---

## 五、模型校准

### 5.1 概率校准

```python
from sklearn.calibration import CalibratedClassifierCV
from sklearn.isotonic import IsotonicRegression

class ModelCalibrator:
    """模型校准器"""
    
    def __init__(self, model):
        self.model = model
        self.calibrator = None
    
    def calibrate_default_probability(self, X_train: np.ndarray, y_train: np.ndarray):
        """
        校准违约概率预测
        
        使用Platt Scaling或Isotonic Regression
        """
        # 训练模型（如果还没训练）
        if not hasattr(self.model, 'predict_proba'):
            self.model.fit(X_train, y_train)
        
        # 使用Platt Scaling校准
        self.calibrator = CalibratedClassifierCV(
            self.model,
            method='sigmoid',  # Platt Scaling
            cv=5
        )
        self.calibrator.fit(X_train, y_train)
        
        return self.calibrator
    
    def predict_calibrated_probability(self, X: np.ndarray) -> np.ndarray:
        """预测校准后的概率"""
        if self.calibrator is None:
            raise ValueError("Model not calibrated yet")
        return self.calibrator.predict_proba(X)[:, 1]
```

### 5.2 利润预测校准

```python
class ProfitCalibrator:
    """利润预测校准器"""
    
    def __init__(self):
        self.calibration_model = None
    
    def calibrate(self, predicted_profits: np.ndarray, actual_profits: np.ndarray):
        """
        校准利润预测
        
        使用线性回归或Isotonic Regression
        """
        from sklearn.linear_model import LinearRegression
        
        # 使用线性回归校准
        X = predicted_profits.reshape(-1, 1)
        y = actual_profits
        
        self.calibration_model = LinearRegression()
        self.calibration_model.fit(X, y)
        
        return self.calibration_model
    
    def predict_calibrated_profit(self, predicted_profits: np.ndarray) -> np.ndarray:
        """预测校准后的利润"""
        if self.calibration_model is None:
            raise ValueError("Model not calibrated yet")
        X = predicted_profits.reshape(-1, 1)
        return self.calibration_model.predict(X)
```

---

## 六、完整拟合流程

### 6.1 完整流程实现

```python
class HistoricalDataFitting:
    """历史数据拟合主类"""
    
    def __init__(self, historical_data_path: str, model):
        self.data_loader = HistoricalDataLoader(historical_data_path)
        self.model = model
        self.predictor = ModelPredictor(model)
        self.comparison = None
        self.evaluator = None
    
    def fit_and_validate(self, split_date: str = None) -> Dict:
        """
        完整的拟合和验证流程
        
        Args:
            split_date: 数据分割日期
        
        Returns:
            完整的评估结果
        """
        # 1. 加载历史数据
        print("1. Loading historical data...")
        historical_data = self.data_loader.load_historical_loans()
        
        # 2. 准备训练集和验证集
        print("2. Preparing train/validation split...")
        train_data, validation_data = self.data_loader.prepare_validation_set(split_date)
        
        # 3. 训练模型（使用训练集）
        print("3. Training model...")
        self.train_model(train_data)
        
        # 4. 在验证集上进行预测
        print("4. Making predictions on validation set...")
        self.comparison = self.compare_with_historical(validation_data)
        
        # 5. 评估拟合度
        print("5. Evaluating fit...")
        self.evaluator = FitEvaluator(self.comparison)
        fit_results = self.evaluator.comprehensive_fit_evaluation()
        
        # 6. 模型校准（如果需要）
        print("6. Calibrating model...")
        if fit_results['default_probability_fit'].get('calibration_error', 1) > 0.1:
            self.calibrate_model(train_data)
            # 重新预测和评估
            self.comparison = self.compare_with_historical(validation_data)
            self.evaluator = FitEvaluator(self.comparison)
            fit_results = self.evaluator.comprehensive_fit_evaluation()
        
        return {
            'fit_results': fit_results,
            'comparison_data': self.comparison,
            'calibration_applied': fit_results['default_probability_fit'].get('calibration_error', 1) <= 0.1
        }
    
    def train_model(self, train_data: pd.DataFrame):
        """训练模型"""
        # 提取特征和标签
        X_train = []
        y_train = []
        
        for _, row in train_data.iterrows():
            features = self.data_loader.extract_features_at_application(row)
            X_train.append(self.features_to_vector(features))
            
            # 标签：是否违约（只针对批准的）
            if row['expert_decision'] == 'approve':
                y_train.append(1 if row['actual_defaulted'] else 0)
            else:
                y_train.append(0)  # 拒绝的视为不违约
        
        X_train = np.array(X_train)
        y_train = np.array(y_train)
        
        # 训练模型
        self.model.fit(X_train, y_train)
    
    def compare_with_historical(self, validation_data: pd.DataFrame) -> pd.DataFrame:
        """与历史数据对比"""
        comparison = HistoricalComparison(validation_data, self.predictor)
        return comparison.compare_predictions()
    
    def calibrate_model(self, train_data: pd.DataFrame):
        """校准模型"""
        # 提取训练数据
        X_train = []
        y_train = []
        
        for _, row in train_data.iterrows():
            if row['expert_decision'] == 'approve':
                features = self.data_loader.extract_features_at_application(row)
                X_train.append(self.features_to_vector(features))
                y_train.append(1 if row['actual_defaulted'] else 0)
        
        X_train = np.array(X_train)
        y_train = np.array(y_train)
        
        # 校准违约概率
        calibrator = ModelCalibrator(self.model)
        calibrator.calibrate_default_probability(X_train, y_train)
        self.predictor.model = calibrator.calibrator
    
    def features_to_vector(self, features: Dict) -> np.ndarray:
        """特征向量化"""
        # 实现特征向量化逻辑
        return np.array([
            features.get('age', 0),
            features.get('monthly_income', 0),
            features.get('credit_score', 0),
            features.get('debt_ratio', 0),
            # ... 其他特征
        ])
    
    def generate_fit_report(self, fit_results: Dict) -> str:
        """生成拟合报告"""
        report = []
        report.append("=" * 80)
        report.append("历史数据拟合评估报告")
        report.append("=" * 80)
        report.append("")
        
        # 决策拟合
        decision_fit = fit_results['decision_fit']
        report.append("一、决策拟合度")
        report.append("-" * 80)
        report.append(f"总体准确率: {decision_fit['overall_accuracy']:.2%}")
        report.append(f"批准决策准确率: {decision_fit['approve_accuracy']:.2%}")
        report.append(f"精确率: {decision_fit['precision']:.2%}")
        report.append(f"召回率: {decision_fit['recall']:.2%}")
        report.append(f"F1分数: {decision_fit['f1_score']:.2%}")
        report.append("")
        
        # 违约概率拟合
        prob_fit = fit_results['default_probability_fit']
        report.append("二、违约概率拟合度")
        report.append("-" * 80)
        report.append(f"实际违约率: {prob_fit['actual_default_rate']:.2%}")
        report.append(f"预测平均违约概率: {prob_fit['predicted_avg_default_prob']:.2%}")
        report.append(f"差异: {prob_fit['default_rate_diff']:.2%}")
        report.append(f"Brier Score: {prob_fit['brier_score']:.4f}")
        report.append(f"校准误差: {prob_fit['calibration_error']:.4f}")
        report.append("")
        
        # 利润拟合
        profit_fit = fit_results['profit_fit']
        report.append("三、利润拟合度")
        report.append("-" * 80)
        report.append(f"相关系数: {profit_fit['correlation']:.4f}")
        report.append(f"平均误差: {profit_fit['mean_error']:.2f}")
        report.append(f"平均绝对误差: {profit_fit['mean_absolute_error']:.2f}")
        report.append(f"RMSE: {profit_fit['root_mean_squared_error']:.2f}")
        report.append(f"R²: {profit_fit['r2_score']:.4f}")
        report.append("")
        
        report.append("=" * 80)
        
        return "\n".join(report)
```

---

## 七、使用示例

### 7.1 完整使用流程

```python
# 1. 初始化
historical_fitting = HistoricalDataFitting(
    historical_data_path='historical_loans.csv',
    model=YourLoanModel()
)

# 2. 执行拟合和验证
results = historical_fitting.fit_and_validate(split_date='2023-01-01')

# 3. 查看结果
print(historical_fitting.generate_fit_report(results['fit_results']))

# 4. 保存对比数据
results['comparison_data'].to_csv('model_vs_historical_comparison.csv', index=False)

# 5. 可视化
import matplotlib.pyplot as plt

# 违约概率校准曲线
comparison = results['comparison_data']
approved = comparison[comparison['historical_decision'] == 'approve']

plt.figure(figsize=(10, 6))
plt.scatter(approved['predicted_default_prob'], approved['historical_defaulted'], alpha=0.5)
plt.plot([0, 1], [0, 1], 'r--', label='Perfect Calibration')
plt.xlabel('Predicted Default Probability')
plt.ylabel('Actual Defaulted (0/1)')
plt.title('Default Probability Calibration')
plt.legend()
plt.savefig('calibration_curve.png')

# 利润预测对比
plt.figure(figsize=(10, 6))
plt.scatter(approved['predicted_profit'], approved['historical_profit'], alpha=0.5)
plt.plot([approved['predicted_profit'].min(), approved['predicted_profit'].max()],
         [approved['predicted_profit'].min(), approved['predicted_profit'].max()],
         'r--', label='Perfect Prediction')
plt.xlabel('Predicted Profit')
plt.ylabel('Actual Profit')
plt.title('Profit Prediction Fit')
plt.legend()
plt.savefig('profit_fit.png')
```

---

## 八、关键要点

### 8.1 数据使用原则

1. **时间分割**：严格按时间分割，避免未来信息泄露
2. **特征提取**：只使用申请时点可用的信息
3. **结果对比**：只对比实际批准的案例

### 8.2 拟合度标准

- **决策准确率**：> 70%
- **违约概率校准误差**：< 0.1
- **利润预测R²**：> 0.6
- **利润预测相关性**：> 0.7

### 8.3 校准策略

1. **概率校准**：使用Platt Scaling或Isotonic Regression
2. **利润校准**：使用线性回归调整
3. **持续监控**：定期重新校准

---

## 九、总结

### 9.1 核心流程

```
历史数据加载
    ↓
时间分割（训练/验证）
    ↓
模型训练（使用训练集）
    ↓
模型预测（在验证集上）
    ↓
对比分析（预测 vs 实际）
    ↓
拟合度评估
    ↓
模型校准（如果需要）
    ↓
生成报告
```

### 9.2 关键指标

- **决策拟合**：准确率、精确率、召回率、F1
- **概率拟合**：Brier Score、校准误差
- **利润拟合**：相关系数、R²、RMSE

### 9.3 注意事项

1. ✅ 严格按时间分割数据
2. ✅ 只使用申请时点信息
3. ✅ 只对比实际批准的案例
4. ✅ 定期重新校准模型
5. ✅ 持续监控拟合度

