# é“¶è¡Œæ•°æ®æå–ä¸ç‰¹å¾å·¥ç¨‹æŒ‡å—

## ğŸ“‹ ç›®å½•
1. [é“¶è¡Œç³»ç»Ÿæ•°æ®æº](#é“¶è¡Œç³»ç»Ÿæ•°æ®æº)
2. [æ•°æ®æå–æ–¹æ¡ˆ](#æ•°æ®æå–æ–¹æ¡ˆ)
3. [ç‰¹å¾å·¥ç¨‹](#ç‰¹å¾å·¥ç¨‹)
4. [æ•°æ®æ¸…æ´—ä¸é¢„å¤„ç†](#æ•°æ®æ¸…æ´—ä¸é¢„å¤„ç†)
5. [å®é™…ä»£ç ç¤ºä¾‹](#å®é™…ä»£ç ç¤ºä¾‹)
6. [æ•°æ®å®‰å…¨ä¸åˆè§„](#æ•°æ®å®‰å…¨ä¸åˆè§„)

---

## ğŸ¦ é“¶è¡Œç³»ç»Ÿæ•°æ®æº

### 1. **æ ¸å¿ƒä¸šåŠ¡ç³»ç»Ÿ**

#### 1.1 å®¢æˆ·å…³ç³»ç®¡ç†ç³»ç»Ÿ (CRM)
- **æ•°æ®å†…å®¹**ï¼š
  - å®¢æˆ·åŸºæœ¬ä¿¡æ¯ï¼ˆå¹´é¾„ã€æ€§åˆ«ã€èŒä¸šã€æ•™è‚²èƒŒæ™¯ï¼‰
  - å®¢æˆ·åˆ†ç±»ï¼ˆä¸ªäºº/ä¼ä¸šã€VIPç­‰çº§ï¼‰
  - å®¢æˆ·æ ‡ç­¾å’Œç”»åƒ
  - å®¢æˆ·å…³ç³»æ—¶é•¿
- **æå–æ–¹å¼**ï¼šæ•°æ®åº“ç›´æ¥æŸ¥è¯¢ã€APIæ¥å£ã€ETLå·¥å…·

#### 1.2 ä¿¡è´·ç®¡ç†ç³»ç»Ÿ (Loan Management System)
- **æ•°æ®å†…å®¹**ï¼š
  - è´·æ¬¾ç”³è¯·è®°å½•ï¼ˆç”³è¯·æ—¶é—´ã€é‡‘é¢ã€ç”¨é€”ã€æœŸé™ï¼‰
  - å®¡æ‰¹ç»“æœï¼ˆé€šè¿‡/æ‹’ç»ã€å®¡æ‰¹äººã€å®¡æ‰¹æ—¶é—´ï¼‰
  - è´·æ¬¾åˆåŒä¿¡æ¯ï¼ˆåˆ©ç‡ã€è¿˜æ¬¾æ–¹å¼ã€æ‹…ä¿æ–¹å¼ï¼‰
  - è´·æ¬¾çŠ¶æ€ï¼ˆæ­£å¸¸ã€é€¾æœŸã€æ ¸é”€ï¼‰
- **æå–æ–¹å¼**ï¼šæ•°æ®åº“æŸ¥è¯¢ã€æ–‡ä»¶å¯¼å‡ºã€APIæ¥å£

#### 1.3 æ ¸å¿ƒé“¶è¡Œç³»ç»Ÿ (Core Banking System)
- **æ•°æ®å†…å®¹**ï¼š
  - è´¦æˆ·ä¿¡æ¯ï¼ˆå­˜æ¬¾ä½™é¢ã€è´¦æˆ·ç±»å‹ã€å¼€æˆ·æ—¶é—´ï¼‰
  - äº¤æ˜“æµæ°´ï¼ˆæ”¶å…¥ã€æ”¯å‡ºã€äº¤æ˜“å¯¹æ‰‹ï¼‰
  - èµ„äº§ä¿¡æ¯ï¼ˆç†è´¢äº§å“ã€åŸºé‡‘ã€ä¿é™©ï¼‰
  - è´Ÿå€ºä¿¡æ¯ï¼ˆä¿¡ç”¨å¡ã€å…¶ä»–è´·æ¬¾ï¼‰
- **æå–æ–¹å¼**ï¼šæ•°æ®åº“æŸ¥è¯¢ã€æ–‡ä»¶ä¼ è¾“ã€æ•°æ®ä»“åº“

#### 1.4 å¾ä¿¡ç³»ç»Ÿ
- **æ•°æ®å†…å®¹**ï¼š
  - å¾ä¿¡è¯„åˆ†
  - å†å²è´·æ¬¾è®°å½•
  - é€¾æœŸè®°å½•
  - æŸ¥è¯¢è®°å½•
- **æå–æ–¹å¼**ï¼šAPIæ¥å£ã€æ–‡ä»¶å¯¼å…¥

### 2. **å¤–éƒ¨æ•°æ®æº**

- **å®è§‚ç»æµæ•°æ®**ï¼šGDPã€CPIã€åˆ©ç‡ã€å¤±ä¸šç‡
- **è¡Œä¸šæ•°æ®**ï¼šè¡Œä¸šæ™¯æ°”åº¦ã€è¡Œä¸šé£é™©
- **ç¬¬ä¸‰æ–¹æ•°æ®**ï¼šå·¥å•†ä¿¡æ¯ã€å¸æ³•ä¿¡æ¯ã€é»‘åå•

---

## ğŸ”§ æ•°æ®æå–æ–¹æ¡ˆ

### æ–¹æ¡ˆä¸€ï¼šæ•°æ®åº“ç›´æ¥æå–ï¼ˆæ¨èï¼‰

#### 1. ä» CRM ç³»ç»Ÿæå–å®¢æˆ·æ•°æ®

```sql
-- ç¤ºä¾‹ï¼šä» CRM æ•°æ®åº“æå–å®¢æˆ·åŸºç¡€ä¿¡æ¯
SELECT 
    customer_id,
    age,
    gender,
    education_level,
    occupation,
    industry,
    city_tier,
    registration_date,
    customer_type,
    vip_level,
    total_assets,
    monthly_income
FROM crm.customer_profile
WHERE registration_date >= '2015-01-01'
  AND status = 'active';
```

#### 2. ä»ä¿¡è´·ç³»ç»Ÿæå–è´·æ¬¾æ•°æ®

```sql
-- ç¤ºä¾‹ï¼šä»ä¿¡è´·ç³»ç»Ÿæå–è´·æ¬¾ç”³è¯·å’Œè¿˜æ¬¾æ•°æ®
SELECT 
    loan_id,
    customer_id,
    apply_date,
    loan_amount,
    loan_purpose,
    term_months,
    interest_rate,
    approval_status,
    approval_date,
    loan_status,
    overdue_days,
    repayment_amount,
    repayment_date
FROM loan.loan_applications la
LEFT JOIN loan.repayment_history rh ON la.loan_id = rh.loan_id
WHERE la.apply_date >= '2015-01-01';
```

#### 3. ä»æ ¸å¿ƒç³»ç»Ÿæå–è´¦æˆ·æ•°æ®

```sql
-- ç¤ºä¾‹ï¼šä»æ ¸å¿ƒç³»ç»Ÿæå–è´¦æˆ·å’Œäº¤æ˜“æ•°æ®
SELECT 
    customer_id,
    account_id,
    account_type,
    account_balance,
    avg_monthly_balance,
    transaction_count,
    transaction_amount,
    last_transaction_date
FROM core.account_summary
WHERE customer_id IN (SELECT customer_id FROM target_customers);
```

### æ–¹æ¡ˆäºŒï¼šAPI æ¥å£æå–

```python
# ç¤ºä¾‹ï¼šé€šè¿‡ API æå–å®¢æˆ·æ•°æ®
import requests
import pandas as pd
from datetime import datetime, timedelta

class BankingDataExtractor:
    """é“¶è¡Œæ•°æ®æå–å™¨"""
    
    def __init__(self, api_base_url, api_key):
        self.api_base_url = api_base_url
        self.headers = {
            'Authorization': f'Bearer {api_key}',
            'Content-Type': 'application/json'
        }
    
    def extract_customer_data(self, start_date, end_date):
        """æå–å®¢æˆ·æ•°æ®"""
        url = f"{self.api_base_url}/api/customers"
        params = {
            'start_date': start_date,
            'end_date': end_date,
            'page_size': 1000
        }
        
        all_data = []
        page = 1
        
        while True:
            params['page'] = page
            response = requests.get(url, headers=self.headers, params=params)
            data = response.json()
            
            if not data.get('results'):
                break
            
            all_data.extend(data['results'])
            
            if not data.get('has_next'):
                break
            
            page += 1
        
        return pd.DataFrame(all_data)
    
    def extract_loan_data(self, customer_ids):
        """æå–è´·æ¬¾æ•°æ®"""
        url = f"{self.api_base_url}/api/loans"
        
        # åˆ†æ‰¹æå–ï¼ˆé¿å…URLè¿‡é•¿ï¼‰
        all_data = []
        batch_size = 100
        
        for i in range(0, len(customer_ids), batch_size):
            batch_ids = customer_ids[i:i+batch_size]
            params = {'customer_ids': ','.join(batch_ids)}
            
            response = requests.get(url, headers=self.headers, params=params)
            data = response.json()
            all_data.extend(data.get('results', []))
        
        return pd.DataFrame(all_data)
```

### æ–¹æ¡ˆä¸‰ï¼šETL å·¥å…·æå–

ä½¿ç”¨ ETL å·¥å…·ï¼ˆå¦‚ Apache Airflowã€Talendã€Informaticaï¼‰ï¼š
- å®šæ—¶ä»»åŠ¡è°ƒåº¦
- æ•°æ®æ¸…æ´—å’Œè½¬æ¢
- æ•°æ®è´¨é‡æ£€æŸ¥
- é”™è¯¯å¤„ç†å’Œé‡è¯•

---

## ğŸ¯ ç‰¹å¾å·¥ç¨‹

### 1. **åŸºç¡€ç‰¹å¾ï¼ˆä»åŸå§‹æ•°æ®ç›´æ¥æå–ï¼‰**

```python
# å®¢æˆ·åŸºç¡€ç‰¹å¾
customer_features = {
    'age': customer.age,
    'gender': customer.gender,
    'education': customer.education_level,
    'industry': customer.industry,
    'city_tier': customer.city_tier,
    'customer_type': customer.customer_type,
    'months_as_customer': (current_date - customer.registration_date).days / 30,
}
```

### 2. **ç»Ÿè®¡ç‰¹å¾ï¼ˆä»å†å²æ•°æ®èšåˆï¼‰**

```python
# ä»äº¤æ˜“æµæ°´è®¡ç®—ç»Ÿè®¡ç‰¹å¾
def calculate_transaction_features(transactions):
    """è®¡ç®—äº¤æ˜“ç»Ÿè®¡ç‰¹å¾"""
    return {
        'avg_monthly_income': transactions[
            transactions['type'] == 'income'
        ]['amount'].mean(),
        'income_volatility': transactions[
            transactions['type'] == 'income'
        ]['amount'].std() / transactions['amount'].mean(),
        'avg_monthly_expense': transactions[
            transactions['type'] == 'expense'
        ]['amount'].mean(),
        'transaction_frequency': len(transactions) / months,
        'savings_rate': (income - expense) / income,
    }

# ä»è´·æ¬¾å†å²è®¡ç®—ç»Ÿè®¡ç‰¹å¾
def calculate_loan_history_features(loan_history):
    """è®¡ç®—è´·æ¬¾å†å²ç‰¹å¾"""
    return {
        'total_loans': len(loan_history),
        'total_loan_amount': loan_history['loan_amount'].sum(),
        'avg_loan_amount': loan_history['loan_amount'].mean(),
        'max_loan_amount': loan_history['loan_amount'].max(),
        'default_count': (loan_history['status'] == 'defaulted').sum(),
        'max_overdue_days': loan_history['overdue_days'].max(),
        'avg_interest_rate': loan_history['interest_rate'].mean(),
        'months_since_last_loan': (current_date - loan_history['apply_date'].max()).days / 30,
    }
```

### 3. **è¡ç”Ÿç‰¹å¾ï¼ˆé€šè¿‡è®¡ç®—å¾—å‡ºï¼‰**

```python
# è´¢åŠ¡æ¯”ç‡ç‰¹å¾
def calculate_financial_ratios(customer):
    """è®¡ç®—è´¢åŠ¡æ¯”ç‡"""
    return {
        'debt_ratio': customer.total_liabilities / max(customer.total_assets, 1),
        'debt_to_income': customer.total_liabilities / max(customer.annual_income, 1),
        'savings_ratio': customer.deposit_balance / max(customer.monthly_income * 12, 1),
        'asset_liability_ratio': customer.total_assets / max(customer.total_liabilities, 1),
    }

# è¡Œä¸ºç‰¹å¾
def calculate_behavioral_features(customer, transactions):
    """è®¡ç®—è¡Œä¸ºç‰¹å¾"""
    return {
        'deposit_stability': calculate_deposit_stability(customer.account_balances),
        'transaction_consistency': calculate_transaction_consistency(transactions),
        'product_usage_diversity': len(customer.products),
        'channel_preference': get_most_used_channel(customer.transactions),
    }
```

### 4. **æ—¶é—´åºåˆ—ç‰¹å¾**

```python
# æ—¶é—´çª—å£ç‰¹å¾
def calculate_time_window_features(data, window_months=6):
    """è®¡ç®—æ—¶é—´çª—å£ç‰¹å¾"""
    recent_data = data[data['date'] >= current_date - timedelta(days=window_months*30)]
    
    return {
        f'avg_balance_last_{window_months}m': recent_data['balance'].mean(),
        f'min_balance_last_{window_months}m': recent_data['balance'].min(),
        f'transaction_trend': calculate_trend(recent_data['transaction_count']),
        f'income_growth_rate': calculate_growth_rate(recent_data['income']),
    }
```

### 5. **äº¤å‰ç‰¹å¾ï¼ˆç‰¹å¾ç»„åˆï¼‰**

```python
# ç‰¹å¾äº¤å‰
def create_interaction_features(customer, loan):
    """åˆ›å»ºäº¤å‰ç‰¹å¾"""
    return {
        'age_loan_amount': customer.age * loan.amount,
        'income_loan_ratio': loan.amount / max(customer.monthly_income * 12, 1),
        'credit_score_loan_amount': customer.credit_score * loan.amount,
        'industry_loan_purpose': f"{customer.industry}_{loan.purpose}",
    }
```

---

## ğŸ§¹ æ•°æ®æ¸…æ´—ä¸é¢„å¤„ç†

### 1. **ç¼ºå¤±å€¼å¤„ç†**

```python
def handle_missing_values(df):
    """å¤„ç†ç¼ºå¤±å€¼"""
    # æ•°å€¼å‹ï¼šç”¨ä¸­ä½æ•°å¡«å……
    numeric_cols = df.select_dtypes(include=[np.number]).columns
    df[numeric_cols] = df[numeric_cols].fillna(df[numeric_cols].median())
    
    # åˆ†ç±»å‹ï¼šç”¨ä¼—æ•°å¡«å……
    categorical_cols = df.select_dtypes(include=['object']).columns
    df[categorical_cols] = df[categorical_cols].fillna(df[categorical_cols].mode().iloc[0])
    
    # ç‰¹æ®Šå¤„ç†ï¼šæ”¶å…¥ä¸º0æˆ–ç¼ºå¤±ï¼Œç”¨è¡Œä¸šå¹³å‡æ”¶å…¥
    if 'monthly_income' in df.columns:
        industry_income = df.groupby('industry')['monthly_income'].transform('median')
        df['monthly_income'] = df['monthly_income'].fillna(industry_income)
    
    return df
```

### 2. **å¼‚å¸¸å€¼å¤„ç†**

```python
def handle_outliers(df, method='iqr'):
    """å¤„ç†å¼‚å¸¸å€¼"""
    numeric_cols = df.select_dtypes(include=[np.number]).columns
    
    for col in numeric_cols:
        if method == 'iqr':
            Q1 = df[col].quantile(0.25)
            Q3 = df[col].quantile(0.75)
            IQR = Q3 - Q1
            lower_bound = Q1 - 1.5 * IQR
            upper_bound = Q3 + 1.5 * IQR
            
            # ç”¨è¾¹ç•Œå€¼æ›¿æ¢å¼‚å¸¸å€¼
            df[col] = df[col].clip(lower=lower_bound, upper=upper_bound)
        
        elif method == 'zscore':
            z_scores = np.abs((df[col] - df[col].mean()) / df[col].std())
            df = df[z_scores < 3]  # åˆ é™¤3ä¸ªæ ‡å‡†å·®å¤–çš„å€¼
    
    return df
```

### 3. **æ•°æ®æ ‡å‡†åŒ–**

```python
from sklearn.preprocessing import StandardScaler, MinMaxScaler, LabelEncoder

def preprocess_features(df, numeric_cols, categorical_cols):
    """ç‰¹å¾é¢„å¤„ç†"""
    # æ•°å€¼ç‰¹å¾æ ‡å‡†åŒ–
    scaler = StandardScaler()
    df[numeric_cols] = scaler.fit_transform(df[numeric_cols])
    
    # åˆ†ç±»ç‰¹å¾ç¼–ç 
    label_encoders = {}
    for col in categorical_cols:
        le = LabelEncoder()
        df[col] = le.fit_transform(df[col].astype(str))
        label_encoders[col] = le
    
    return df, scaler, label_encoders
```

---

## ğŸ’» å®é™…ä»£ç ç¤ºä¾‹

### å®Œæ•´çš„æ•°æ®æå–å’Œç‰¹å¾å·¥ç¨‹æµç¨‹

```python
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
from typing import Dict, List

class BankingDataPipeline:
    """é“¶è¡Œæ•°æ®æå–å’Œç‰¹å¾å·¥ç¨‹ç®¡é“"""
    
    def __init__(self, db_connection):
        self.db = db_connection
    
    def extract_customer_data(self, start_date, end_date) -> pd.DataFrame:
        """æ­¥éª¤1ï¼šæå–å®¢æˆ·åŸºç¡€æ•°æ®"""
        query = """
        SELECT 
            c.customer_id,
            c.age,
            c.gender,
            c.education_level,
            c.occupation,
            c.industry,
            c.city_tier,
            c.registration_date,
            c.customer_type,
            c.vip_level,
            c.total_assets,
            c.monthly_income
        FROM crm.customer_profile c
        WHERE c.registration_date >= %s
          AND c.registration_date <= %s
          AND c.status = 'active'
        """
        return pd.read_sql(query, self.db, params=[start_date, end_date])
    
    def extract_account_data(self, customer_ids: List[str]) -> pd.DataFrame:
        """æ­¥éª¤2ï¼šæå–è´¦æˆ·æ•°æ®"""
        query = """
        SELECT 
            a.customer_id,
            SUM(a.account_balance) as total_deposit_balance,
            AVG(a.account_balance) as avg_account_balance,
            COUNT(DISTINCT a.account_id) as account_count,
            MIN(a.open_date) as first_account_date
        FROM core.accounts a
        WHERE a.customer_id IN %s
        GROUP BY a.customer_id
        """
        return pd.read_sql(query, self.db, params=[tuple(customer_ids)])
    
    def extract_transaction_data(self, customer_ids: List[str], months: int = 12) -> pd.DataFrame:
        """æ­¥éª¤3ï¼šæå–äº¤æ˜“æ•°æ®"""
        start_date = datetime.now() - timedelta(days=months*30)
        
        query = """
        SELECT 
            t.customer_id,
            t.transaction_type,
            t.transaction_amount,
            t.transaction_date,
            COUNT(*) OVER (PARTITION BY t.customer_id) as transaction_count,
            SUM(CASE WHEN t.transaction_type = 'income' THEN t.transaction_amount ELSE 0 END) 
                OVER (PARTITION BY t.customer_id) as total_income,
            SUM(CASE WHEN t.transaction_type = 'expense' THEN t.transaction_amount ELSE 0 END) 
                OVER (PARTITION BY t.customer_id) as total_expense
        FROM core.transactions t
        WHERE t.customer_id IN %s
          AND t.transaction_date >= %s
        """
        return pd.read_sql(query, self.db, params=[tuple(customer_ids), start_date])
    
    def extract_loan_history(self, customer_ids: List[str]) -> pd.DataFrame:
        """æ­¥éª¤4ï¼šæå–è´·æ¬¾å†å²"""
        query = """
        SELECT 
            l.customer_id,
            COUNT(*) as total_loans,
            SUM(l.loan_amount) as total_loan_amount,
            AVG(l.loan_amount) as avg_loan_amount,
            MAX(l.loan_amount) as max_loan_amount,
            SUM(CASE WHEN l.loan_status = 'defaulted' THEN 1 ELSE 0 END) as default_count,
            MAX(l.overdue_days) as max_overdue_days,
            AVG(l.interest_rate) as avg_interest_rate,
            MAX(l.apply_date) as last_loan_date
        FROM loan.loan_applications l
        WHERE l.customer_id IN %s
        GROUP BY l.customer_id
        """
        return pd.read_sql(query, self.db, params=[tuple(customer_ids)])
    
    def build_features(self, customers: pd.DataFrame) -> pd.DataFrame:
        """æ­¥éª¤5ï¼šæ„å»ºç‰¹å¾"""
        customer_ids = customers['customer_id'].tolist()
        
        # æå–å„ç»´åº¦æ•°æ®
        accounts = self.extract_account_data(customer_ids)
        transactions = self.extract_transaction_data(customer_ids)
        loans = self.extract_loan_history(customer_ids)
        
        # åˆå¹¶æ•°æ®
        features = customers.copy()
        features = features.merge(accounts, on='customer_id', how='left')
        features = features.merge(loans, on='customer_id', how='left')
        
        # è®¡ç®—äº¤æ˜“ç‰¹å¾
        transaction_features = transactions.groupby('customer_id').agg({
            'transaction_amount': ['mean', 'std', 'sum'],
            'transaction_count': 'count',
            'total_income': 'first',
            'total_expense': 'first',
        }).reset_index()
        transaction_features.columns = ['customer_id', 'avg_transaction', 
                                        'transaction_std', 'transaction_sum',
                                        'transaction_count', 'total_income', 'total_expense']
        
        features = features.merge(transaction_features, on='customer_id', how='left')
        
        # è®¡ç®—è¡ç”Ÿç‰¹å¾
        features['debt_ratio'] = features['total_liabilities'] / (features['total_assets'] + 1)
        features['debt_to_income'] = features['total_liabilities'] / (features['monthly_income'] * 12 + 1)
        features['savings_rate'] = (features['total_income'] - features['total_expense']) / (features['total_income'] + 1)
        features['income_volatility'] = features['transaction_std'] / (features['avg_transaction'] + 1)
        features['months_as_customer'] = (datetime.now() - pd.to_datetime(features['registration_date'])).dt.days / 30
        features['months_since_last_loan'] = (datetime.now() - pd.to_datetime(features['last_loan_date'])).dt.days / 30
        
        # å¤„ç†ç¼ºå¤±å€¼
        features = self.handle_missing_values(features)
        
        return features
    
    def handle_missing_values(self, df: pd.DataFrame) -> pd.DataFrame:
        """å¤„ç†ç¼ºå¤±å€¼"""
        # æ•°å€¼å‹ç”¨ä¸­ä½æ•°
        numeric_cols = df.select_dtypes(include=[np.number]).columns
        df[numeric_cols] = df[numeric_cols].fillna(df[numeric_cols].median())
        
        # åˆ†ç±»å‹ç”¨ä¼—æ•°
        categorical_cols = df.select_dtypes(include=['object']).columns
        for col in categorical_cols:
            df[col] = df[col].fillna(df[col].mode()[0] if len(df[col].mode()) > 0 else 'unknown')
        
        return df

# ä½¿ç”¨ç¤ºä¾‹
if __name__ == '__main__':
    from sqlalchemy import create_engine
    
    # è¿æ¥æ•°æ®åº“
    engine = create_engine('postgresql://user:password@host:port/database')
    
    # åˆ›å»ºç®¡é“
    pipeline = BankingDataPipeline(engine)
    
    # æå–æ•°æ®
    start_date = '2015-01-01'
    end_date = '2024-12-31'
    
    customers = pipeline.extract_customer_data(start_date, end_date)
    features = pipeline.build_features(customers)
    
    # ä¿å­˜ç‰¹å¾æ•°æ®
    features.to_parquet('data/extracted_features.parquet', index=False)
    print(f"âœ… ç‰¹å¾æå–å®Œæˆï¼Œå…± {len(features):,} æ¡è®°å½•")
```

---

## ğŸ”’ æ•°æ®å®‰å…¨ä¸åˆè§„

### 1. **æ•°æ®è„±æ•**

```python
def anonymize_data(df):
    """æ•°æ®è„±æ•"""
    # åˆ é™¤æˆ–åŠ å¯†æ•æ„Ÿä¿¡æ¯
    sensitive_cols = ['customer_id', 'id_card', 'phone', 'email', 'address']
    
    for col in sensitive_cols:
        if col in df.columns:
            if col == 'customer_id':
                # ä½¿ç”¨å“ˆå¸ŒID
                df[col] = df[col].apply(lambda x: hashlib.md5(str(x).encode()).hexdigest())
            else:
                # åˆ é™¤æ•æ„Ÿåˆ—
                df = df.drop(columns=[col])
    
    return df
```

### 2. **æ•°æ®æƒé™æ§åˆ¶**

- æœ€å°æƒé™åŸåˆ™
- æ•°æ®è®¿é—®æ—¥å¿—
- å®šæœŸå®¡è®¡

### 3. **åˆè§„è¦æ±‚**

- ç¬¦åˆã€Šä¸ªäººä¿¡æ¯ä¿æŠ¤æ³•ã€‹
- ç¬¦åˆã€Šæ•°æ®å®‰å…¨æ³•ã€‹
- ç¬¦åˆé“¶è¡Œç›‘ç®¡è¦æ±‚
- æ•°æ®ä½¿ç”¨æˆæƒ

---

## ğŸ“š æ€»ç»“

### æ•°æ®æå–æµç¨‹
1. **è¯†åˆ«æ•°æ®æº** â†’ CRMã€ä¿¡è´·ç³»ç»Ÿã€æ ¸å¿ƒç³»ç»Ÿ
2. **é€‰æ‹©æå–æ–¹å¼** â†’ æ•°æ®åº“æŸ¥è¯¢ã€APIã€ETLå·¥å…·
3. **æå–åŸå§‹æ•°æ®** â†’ å®¢æˆ·ã€è´¦æˆ·ã€äº¤æ˜“ã€è´·æ¬¾
4. **æ•°æ®æ¸…æ´—** â†’ ç¼ºå¤±å€¼ã€å¼‚å¸¸å€¼å¤„ç†
5. **ç‰¹å¾å·¥ç¨‹** â†’ åŸºç¡€ç‰¹å¾ã€ç»Ÿè®¡ç‰¹å¾ã€è¡ç”Ÿç‰¹å¾
6. **æ•°æ®å­˜å‚¨** â†’ Parquetæ ¼å¼ã€æ•°æ®ä»“åº“

### å…³é”®ç‰¹å¾ç±»åˆ«
- **å®¢æˆ·åŸºç¡€ç‰¹å¾**ï¼šå¹´é¾„ã€æ€§åˆ«ã€æ•™è‚²ã€è¡Œä¸š
- **è´¢åŠ¡ç‰¹å¾**ï¼šæ”¶å…¥ã€èµ„äº§ã€è´Ÿå€ºã€å­˜æ¬¾
- **è¡Œä¸ºç‰¹å¾**ï¼šäº¤æ˜“é¢‘ç‡ã€å­˜æ¬¾ç¨³å®šæ€§
- **å†å²ç‰¹å¾**ï¼šè´·æ¬¾å†å²ã€é€¾æœŸè®°å½•
- **æ—¶é—´ç‰¹å¾**ï¼šå®¢æˆ·æ—¶é•¿ã€è·ä¸Šæ¬¡è´·æ¬¾æ—¶é—´

### æœ€ä½³å®è·µ
- âœ… ä½¿ç”¨å¢é‡æå–ï¼Œé¿å…å…¨é‡æ‰«æ
- âœ… ç‰¹å¾è®¡ç®—å¯å¤ç”¨ï¼Œé¿å…é‡å¤è®¡ç®—
- âœ… æ•°æ®è„±æ•ï¼Œä¿æŠ¤éšç§
- âœ… ç‰ˆæœ¬æ§åˆ¶ï¼Œç‰¹å¾å¯è¿½æº¯
- âœ… æ–‡æ¡£å®Œå–„ï¼Œä¾¿äºç»´æŠ¤

