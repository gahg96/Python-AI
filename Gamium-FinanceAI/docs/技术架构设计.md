# Gamium 金融决策系统 - 技术架构设计

## 1. 系统总览

基于 AlphaZero 思想的金融行业经营决策系统，核心是将商业决策问题建模为**多智能体博弈游戏**，通过自我对弈发现最优策略。

### 1.1 核心技术栈

```
┌──────────────────────────────────────────────────────────────────────┐
│                        技术栈选型                                     │
├──────────────────────────────────────────────────────────────────────┤
│  前端展示    │  React + D3.js + Three.js (3D可视化)                   │
│  后端服务    │  Python (FastAPI) + Go (高性能模拟引擎)                │
│  AI框架      │  PyTorch + Ray/RLlib (分布式强化学习)                  │
│  模拟引擎    │  自研 (Python/Cython) 或 Mesa (ABM框架)                │
│  数据存储    │  PostgreSQL + Redis + ClickHouse (时序分析)            │
│  消息队列    │  Kafka (实时事件流)                                    │
│  容器编排    │  Kubernetes + Docker                                   │
└──────────────────────────────────────────────────────────────────────┘
```

## 2. 核心模块设计

### 2.1 模拟环境层 (Environment Layer)

这是 AlphaZero 的"棋盘"，需要构建一个可重复、可加速的金融世界模拟器。

#### 2.1.1 用户行为模拟器

```python
class CustomerSimulator:
    """
    模拟客户的信贷行为：申请、还款、违约、流失
    """
    
    def __init__(self, customer_profiles: DataFrame):
        self.customers = self._init_customers(customer_profiles)
        self.behavior_model = self._load_behavior_model()
    
    def step(self, action: LendingAction) -> CustomerResponse:
        """
        根据信贷动作，模拟客户响应
        
        Args:
            action: 额度、利率、产品类型等
        Returns:
            CustomerResponse: 接受/拒绝、还款行为、违约概率
        """
        pass
    
    def simulate_repayment(self, loan: Loan, economic_state: EconomicState):
        """模拟还款行为，考虑经济周期影响"""
        pass
```

#### 2.1.2 宏观经济模拟器

```python
class EconomicCycleSimulator:
    """
    模拟宏观经济周期：GDP、利率、失业率、行业景气度
    """
    
    # 经济状态：繁荣、衰退、萧条、复苏
    STATES = ['boom', 'recession', 'depression', 'recovery']
    
    def __init__(self, config: EconomicConfig):
        self.gdp_model = GDPModel(config)
        self.interest_rate_model = InterestRateModel(config)
        self.unemployment_model = UnemploymentModel(config)
        self.industry_model = IndustryHealthModel(config)
    
    def step(self) -> EconomicState:
        """推进一个时间步（月/季度）"""
        pass
    
    def inject_shock(self, shock_type: str, magnitude: float):
        """注入黑天鹅事件"""
        pass
```

#### 2.1.3 市场竞争模拟器

```python
class MarketSimulator:
    """
    模拟市场竞争动态：竞争对手行为、市场份额变化
    """
    
    def __init__(self, num_competitors: int):
        self.competitors = [CompetitorAgent(i) for i in range(num_competitors)]
        self.market_share = {}
    
    def step(self, our_action: MarketAction) -> MarketOutcome:
        """模拟一轮市场竞争"""
        pass
```

### 2.2 Gamium 核心平台层

#### 2.2.1 游戏引擎 (Game Engine)

```python
class GamiumGameEngine:
    """
    核心博弈引擎 - 管理整个模拟过程
    """
    
    def __init__(self, config: GameConfig):
        self.environment = FinanceEnvironment(config)
        self.players = []  # 策略智能体列表
        self.current_round = 0
        self.max_rounds = config.simulation_years * 12  # 按月计算
        self.history = GameHistory()
    
    def register_player(self, player: StrategyAgent):
        """注册一个策略玩家"""
        self.players.append(player)
    
    def run_simulation(self) -> SimulationResult:
        """运行完整模拟"""
        while self.current_round < self.max_rounds:
            # 1. 获取当前状态
            state = self.environment.get_state()
            
            # 2. 每个玩家做出决策
            actions = {}
            for player in self.players:
                actions[player.id] = player.decide(state)
            
            # 3. 环境执行动作并返回奖励
            rewards, next_state = self.environment.step(actions)
            
            # 4. 记录历史
            self.history.record(state, actions, rewards)
            
            # 5. 检查是否有"破产"玩家
            self._check_bankruptcy()
            
            self.current_round += 1
        
        return self._compile_results()
```

#### 2.2.2 状态空间定义

```python
@dataclass
class FinanceState:
    """金融博弈的状态表示"""
    
    # 宏观经济状态
    gdp_growth: float           # GDP 增长率
    interest_rate: float        # 基准利率
    unemployment_rate: float    # 失业率
    inflation_rate: float       # 通胀率
    economic_cycle_phase: str   # 经济周期阶段
    
    # 市场状态
    market_share: float         # 我方市场份额
    competitor_rates: List[float]  # 竞争对手利率
    industry_health: Dict[str, float]  # 各行业健康度
    
    # 自身状态
    total_assets: float         # 总资产
    loan_portfolio: LoanPortfolio  # 贷款组合
    capital_adequacy_ratio: float  # 资本充足率
    npl_ratio: float            # 不良贷款率
    liquidity_ratio: float      # 流动性比率
    
    # 客群状态
    customer_segments: Dict[str, SegmentState]  # 各客群状态
```

#### 2.2.3 动作空间定义

```python
@dataclass
class LendingAction:
    """信贷策略动作"""
    
    # 产品定价
    interest_rate_adjustment: float  # 利率调整幅度 (-0.02 ~ +0.02)
    
    # 风控策略
    approval_threshold: float        # 审批门槛调整
    credit_limit_policy: str         # 额度策略: 'conservative', 'moderate', 'aggressive'
    
    # 客群策略
    target_segments: List[str]       # 重点客群
    segment_budgets: Dict[str, float]  # 各客群营销预算
    
    # 产品策略
    new_products: List[ProductConfig]  # 新产品推出
    product_adjustments: Dict[str, ProductChange]  # 产品调整
    
    # 催收策略
    collection_intensity: str        # 催收强度
    write_off_threshold: int         # 核销天数阈值
```

### 2.3 AI 智能体层 (AlphaZero 架构)

#### 2.3.1 神经网络架构

```python
import torch
import torch.nn as nn

class GamiumNetwork(nn.Module):
    """
    AlphaZero 风格的双头网络
    - 策略头 (Policy Head): 输出动作概率分布
    - 价值头 (Value Head): 评估当前状态的价值
    """
    
    def __init__(self, state_dim: int, action_dim: int, hidden_dim: int = 512):
        super().__init__()
        
        # 共享特征提取器
        self.feature_extractor = nn.Sequential(
            nn.Linear(state_dim, hidden_dim),
            nn.ReLU(),
            nn.Linear(hidden_dim, hidden_dim),
            nn.ReLU(),
            nn.Linear(hidden_dim, hidden_dim),
            nn.ReLU(),
        )
        
        # Transformer 层 (捕捉时序依赖)
        self.transformer = nn.TransformerEncoder(
            nn.TransformerEncoderLayer(d_model=hidden_dim, nhead=8),
            num_layers=4
        )
        
        # 策略头
        self.policy_head = nn.Sequential(
            nn.Linear(hidden_dim, hidden_dim // 2),
            nn.ReLU(),
            nn.Linear(hidden_dim // 2, action_dim),
            nn.Softmax(dim=-1)
        )
        
        # 价值头
        self.value_head = nn.Sequential(
            nn.Linear(hidden_dim, hidden_dim // 2),
            nn.ReLU(),
            nn.Linear(hidden_dim // 2, 1),
            nn.Tanh()  # 输出 [-1, 1] 范围的价值估计
        )
    
    def forward(self, state: torch.Tensor) -> Tuple[torch.Tensor, torch.Tensor]:
        features = self.feature_extractor(state)
        policy = self.policy_head(features)
        value = self.value_head(features)
        return policy, value
```

#### 2.3.2 蒙特卡洛树搜索 (MCTS)

```python
class MCTS:
    """
    蒙特卡洛树搜索 - AlphaZero 的核心决策算法
    """
    
    def __init__(self, network: GamiumNetwork, num_simulations: int = 800):
        self.network = network
        self.num_simulations = num_simulations
        self.c_puct = 1.0  # 探索常数
    
    def search(self, state: FinanceState, env: FinanceEnvironment) -> Action:
        """执行 MCTS 搜索，返回最佳动作"""
        root = Node(state)
        
        for _ in range(self.num_simulations):
            node = root
            sim_env = env.clone()
            
            # 1. 选择 (Selection)
            while node.is_expanded and not node.is_terminal:
                action, node = self._select_child(node)
                sim_env.step({0: action})
            
            # 2. 扩展 (Expansion)
            if not node.is_terminal:
                policy, value = self.network(node.state.to_tensor())
                node.expand(policy)
            else:
                value = self._get_terminal_value(node)
            
            # 3. 回溯 (Backpropagation)
            self._backpropagate(node, value)
        
        # 返回访问次数最多的动作
        return root.get_best_action()
    
    def _select_child(self, node: Node) -> Tuple[Action, Node]:
        """UCB1 选择公式"""
        best_score = -float('inf')
        best_action, best_child = None, None
        
        for action, child in node.children.items():
            # PUCT 公式
            q_value = child.value / (child.visit_count + 1e-8)
            u_value = self.c_puct * child.prior * math.sqrt(node.visit_count) / (1 + child.visit_count)
            score = q_value + u_value
            
            if score > best_score:
                best_score = score
                best_action, best_child = action, child
        
        return best_action, best_child
```

#### 2.3.3 自我对弈训练

```python
class AlphaZeroTrainer:
    """
    AlphaZero 自我对弈训练循环
    """
    
    def __init__(self, config: TrainingConfig):
        self.network = GamiumNetwork(config.state_dim, config.action_dim)
        self.optimizer = torch.optim.Adam(self.network.parameters(), lr=config.lr)
        self.replay_buffer = ReplayBuffer(config.buffer_size)
        self.config = config
    
    def train(self, num_iterations: int):
        """主训练循环"""
        for iteration in range(num_iterations):
            # 1. 自我对弈生成训练数据
            game_data = self._self_play()
            self.replay_buffer.add(game_data)
            
            # 2. 从缓冲区采样训练网络
            for _ in range(self.config.train_steps_per_iteration):
                batch = self.replay_buffer.sample(self.config.batch_size)
                loss = self._train_step(batch)
            
            # 3. 评估新网络
            if iteration % self.config.eval_interval == 0:
                win_rate = self._evaluate_against_baseline()
                print(f"Iteration {iteration}: Win rate = {win_rate:.2%}")
            
            # 4. 保存检查点
            if iteration % self.config.save_interval == 0:
                self._save_checkpoint(iteration)
    
    def _self_play(self) -> List[TrainingExample]:
        """执行一局自我对弈"""
        env = FinanceEnvironment(self.config.env_config)
        mcts = MCTS(self.network, self.config.num_simulations)
        
        examples = []
        state = env.reset()
        
        while not env.is_terminal():
            # MCTS 搜索
            action_probs = mcts.get_action_probs(state, env)
            
            # 记录训练样本
            examples.append((state, action_probs, None))  # value 稍后填充
            
            # 采样动作
            action = np.random.choice(len(action_probs), p=action_probs)
            state, reward, done, _ = env.step(action)
        
        # 回填最终价值
        final_value = self._compute_final_value(env)
        return [(s, p, final_value * (0.99 ** (len(examples) - i))) 
                for i, (s, p, _) in enumerate(examples)]
```

### 2.4 评估指标体系

```python
@dataclass
class PerformanceMetrics:
    """策略评估指标 - "北极星指标"体系"""
    
    # 财务指标
    total_profit: float          # 总利润
    roa: float                   # 资产回报率
    roe: float                   # 股东权益回报率
    net_interest_margin: float   # 净息差
    
    # 风险指标
    npl_ratio: float             # 不良贷款率
    provision_coverage: float    # 拨备覆盖率
    capital_adequacy: float      # 资本充足率
    max_drawdown: float          # 最大回撤
    
    # 增长指标
    market_share_growth: float   # 市场份额增长
    customer_growth: float       # 客户增长率
    aum_growth: float            # 资产管理规模增长
    
    # 穿越周期能力
    recession_survival: bool     # 是否安全度过衰退期
    recovery_speed: float        # 复苏速度
    volatility: float            # 收益波动率
    sharpe_ratio: float          # 夏普比率
    
    def compute_composite_score(self) -> float:
        """
        计算综合得分 - 单一"北极星指标"
        权重可根据业务优先级调整
        """
        score = (
            self.roa * 30 +           # 盈利能力 30%
            (1 - self.npl_ratio) * 25 +  # 风险控制 25%
            self.sharpe_ratio * 20 +   # 风险调整收益 20%
            self.market_share_growth * 15 +  # 增长能力 15%
            (1 if self.recession_survival else 0) * 10  # 穿越周期 10%
        )
        return score
```

## 3. 数据流设计

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                            数据流架构                                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐    ┌─────────────┐  │
│  │ 原始数据    │───→│ 数据蒸馏    │───→│ 行为建模    │───→│ 模拟器参数  │  │
│  │ (历史交易)  │    │ (脱敏/统计) │    │ (ML模型)    │    │ (校准完成)  │  │
│  └─────────────┘    └─────────────┘    └─────────────┘    └─────────────┘  │
│                                                                    │        │
│                                                                    ▼        │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐    ┌─────────────┐  │
│  │ 策略输出    │←───│ AI 智能体   │←───│ MCTS 搜索   │←───│ 模拟环境    │  │
│  │ (可解释)    │    │ (神经网络)  │    │ (决策树)    │    │ (数字孪生)  │  │
│  └─────────────┘    └─────────────┘    └─────────────┘    └─────────────┘  │
│        │                                                                    │
│        ▼                                                                    │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                    战略演武场仪表盘                                   │   │
│  │  - 策略对抗实时可视化                                                 │   │
│  │  - 关键指标趋势图                                                     │   │
│  │  - 策略决策可解释性报告                                               │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

## 4. 项目里程碑

### Phase 1: POC (1-2个月)
- [ ] 简化版信贷环境模拟器
- [ ] 基础 AlphaZero 智能体
- [ ] 命令行版本对弈演示

### Phase 2: MVP (3-4个月)
- [ ] 完整经济周期模拟
- [ ] 多策略对抗
- [ ] Web 可视化仪表盘

### Phase 3: 产品化 (6个月+)
- [ ] 分布式训练系统
- [ ] 生产级模拟精度
- [ ] 影子模式部署

## 5. 技术挑战与解决方案

| 挑战 | 解决方案 |
|------|---------|
| **状态空间高维** | 使用 Transformer 编码时序特征，自动学习关键特征 |
| **动作空间连续** | 动作离散化 + 层次化动作空间 |
| **模拟精度** | 历史数据校准 + 专家规则修正 + 定期回测验证 |
| **训练时间长** | Ray 分布式训练 + GPU 加速 + 模型压缩 |
| **策略可解释性** | 注意力可视化 + 关键决策点分析 + 反事实解释 |
| **合规红线** | 硬编码监管约束为不可违反规则 |

## 6. 开发团队建议

| 角色 | 人数 | 职责 |
|------|------|------|
| 项目经理 | 1 | 整体协调，与业务对接 |
| AI 工程师 | 2-3 | AlphaZero 实现，模型训练 |
| 后端工程师 | 2 | 模拟引擎，API 开发 |
| 前端工程师 | 1-2 | 可视化仪表盘 |
| 金融业务专家 | 1 | 业务规则定义，模型校验 |
| 数据工程师 | 1 | 数据管道，特征工程 |

---

*文档版本: v0.1*  
*创建日期: 2024年12月7日*


