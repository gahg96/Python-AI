# 模拟环境放贷决策验证方案

## 一、问题核心

在模拟环境中测试放贷决策时，我们需要验证：
1. **模拟环境的准确性**：环境是否真实反映现实？
2. **决策的正确性**：放贷决策是否合理？
3. **结果的可靠性**：结果是否可信？

---

## 二、验证框架

### 2.1 三层验证体系

```
第一层：环境验证
    ↓
第二层：决策验证
    ↓
第三层：结果验证
```

---

## 三、第一层：环境验证

### 3.1 数据分布验证

#### 3.1.1 客户特征分布验证

```python
import numpy as np
import pandas as pd
from scipy import stats

class EnvironmentValidator:
    """环境验证器"""
    
    def __init__(self, historical_data: pd.DataFrame, simulated_data: pd.DataFrame):
        self.historical = historical_data
        self.simulated = simulated_data
    
    def validate_distribution(self, field: str, tolerance: float = 0.05):
        """
        验证模拟数据的分布是否与历史数据一致
        
        Args:
            field: 要验证的字段名
            tolerance: 允许的差异容忍度
        
        Returns:
            (is_valid, statistics)
        """
        hist_values = self.historical[field].values
        sim_values = self.simulated[field].values
        
        # 1. Kolmogorov-Smirnov 检验
        ks_statistic, ks_pvalue = stats.ks_2samp(hist_values, sim_values)
        
        # 2. 均值检验
        hist_mean = np.mean(hist_values)
        sim_mean = np.mean(sim_values)
        mean_diff = abs(hist_mean - sim_mean) / hist_mean
        
        # 3. 标准差检验
        hist_std = np.std(hist_values)
        sim_std = np.std(sim_values)
        std_diff = abs(hist_std - sim_std) / hist_std
        
        # 4. 分位数检验
        percentiles = [10, 25, 50, 75, 90]
        hist_percentiles = np.percentile(hist_values, percentiles)
        sim_percentiles = np.percentile(sim_values, percentiles)
        percentile_diffs = np.abs(hist_percentiles - sim_percentiles) / hist_percentiles
        
        is_valid = (
            ks_pvalue > 0.05 and  # KS检验通过
            mean_diff < tolerance and  # 均值差异在容忍范围内
            std_diff < tolerance and  # 标准差差异在容忍范围内
            np.all(percentile_diffs < tolerance)  # 所有分位数差异在容忍范围内
        )
        
        statistics = {
            'ks_statistic': ks_statistic,
            'ks_pvalue': ks_pvalue,
            'mean_diff': mean_diff,
            'std_diff': std_diff,
            'percentile_diffs': dict(zip(percentiles, percentile_diffs)),
            'is_valid': is_valid
        }
        
        return is_valid, statistics
    
    def validate_all_fields(self, fields: List[str]):
        """验证所有字段的分布"""
        results = {}
        for field in fields:
            is_valid, stats = self.validate_distribution(field)
            results[field] = {
                'valid': is_valid,
                'statistics': stats
            }
        return results
```

#### 3.1.2 违约率验证

```python
def validate_default_rate(self, tolerance: float = 0.02):
    """
    验证模拟环境的违约率是否与历史数据一致
    
    Args:
        tolerance: 允许的违约率差异（如0.02表示2%）
    """
    # 历史违约率
    hist_default_rate = self.historical['defaulted'].mean()
    
    # 模拟违约率（需要运行多次模拟取平均）
    sim_default_rates = []
    for _ in range(100):  # 运行100次模拟
        # 生成模拟数据并计算违约率
        sim_data = self.generate_simulation()
        sim_default_rate = sim_data['defaulted'].mean()
        sim_default_rates.append(sim_default_rate)
    
    avg_sim_rate = np.mean(sim_default_rates)
    std_sim_rate = np.std(sim_default_rates)
    
    # 检查是否在置信区间内
    diff = abs(hist_default_rate - avg_sim_rate)
    is_valid = diff < tolerance
    
    return {
        'historical_rate': hist_default_rate,
        'simulated_rate': avg_sim_rate,
        'simulated_std': std_sim_rate,
        'difference': diff,
        'is_valid': is_valid,
        'confidence_interval': (
            avg_sim_rate - 1.96 * std_sim_rate,
            avg_sim_rate + 1.96 * std_sim_rate
        )
    }
```

### 3.2 因果关系验证

```python
def validate_causality(self):
    """
    验证模拟环境中的因果关系是否合理
    
    例如：收入越高，违约率应该越低
    """
    # 1. 收入与违约率的关系
    income_bins = np.percentile(self.historical['monthly_income'], [0, 25, 50, 75, 100])
    hist_income_default = []
    sim_income_default = []
    
    for i in range(len(income_bins) - 1):
        hist_bin = self.historical[
            (self.historical['monthly_income'] >= income_bins[i]) &
            (self.historical['monthly_income'] < income_bins[i+1])
        ]
        hist_default_rate = hist_bin['defaulted'].mean()
        hist_income_default.append(hist_default_rate)
        
        # 模拟数据
        sim_bin = self.simulated[
            (self.simulated['monthly_income'] >= income_bins[i]) &
            (self.simulated['monthly_income'] < income_bins[i+1])
        ]
        sim_default_rate = sim_bin['defaulted'].mean()
        sim_income_default.append(sim_default_rate)
    
    # 检查趋势是否一致（收入越高，违约率越低）
    hist_trend = np.corrcoef(range(len(hist_income_default)), hist_income_default)[0, 1]
    sim_trend = np.corrcoef(range(len(sim_income_default)), sim_income_default)[0, 1]
    
    is_valid = (
        hist_trend < 0 and sim_trend < 0 and  # 都应该是负相关
        abs(hist_trend - sim_trend) < 0.2  # 趋势相似
    )
    
    return {
        'historical_trend': hist_trend,
        'simulated_trend': sim_trend,
        'is_valid': is_valid
    }
```

---

## 四、第二层：决策验证

### 4.1 与历史决策对比

#### 4.1.1 决策一致性验证

```python
class DecisionValidator:
    """决策验证器"""
    
    def __init__(self, historical_decisions: pd.DataFrame, model_decisions: pd.DataFrame):
        self.historical = historical_decisions
        self.model = model_decisions
    
    def validate_decision_consistency(self):
        """
        验证模型决策与历史专家决策的一致性
        """
        # 合并数据（基于客户ID）
        merged = pd.merge(
            self.historical[['customer_id', 'expert_decision']],
            self.model[['customer_id', 'model_decision']],
            on='customer_id'
        )
        
        # 计算一致性指标
        total = len(merged)
        agreed = (merged['expert_decision'] == merged['model_decision']).sum()
        agreement_rate = agreed / total
        
        # 分类统计
        # 专家通过，模型通过
        both_approve = ((merged['expert_decision'] == 'approve') & 
                       (merged['model_decision'] == 'approve')).sum()
        # 专家拒绝，模型拒绝
        both_reject = ((merged['expert_decision'] == 'reject') & 
                      (merged['model_decision'] == 'reject')).sum()
        # 专家通过，模型拒绝（保守）
        expert_approve_model_reject = ((merged['expert_decision'] == 'approve') & 
                                      (merged['model_decision'] == 'reject')).sum()
        # 专家拒绝，模型通过（激进）
        expert_reject_model_approve = ((merged['expert_decision'] == 'reject') & 
                                      (merged['model_decision'] == 'approve')).sum()
        
        return {
            'total_cases': total,
            'agreement_rate': agreement_rate,
            'both_approve': both_approve,
            'both_reject': both_reject,
            'expert_approve_model_reject': expert_approve_model_reject,  # 保守决策
            'expert_reject_model_approve': expert_reject_model_approve,  # 激进决策
            'is_acceptable': agreement_rate > 0.7  # 70%以上一致认为可接受
        }
    
    def validate_decision_quality(self):
        """
        验证决策质量：比较实际结果
        """
        merged = pd.merge(
            self.historical[['customer_id', 'expert_decision', 'actual_outcome']],
            self.model[['customer_id', 'model_decision', 'predicted_outcome']],
            on='customer_id'
        )
        
        # 1. 专家决策的实际结果
        expert_approved = merged[merged['expert_decision'] == 'approve']
        expert_default_rate = expert_approved['actual_outcome'].apply(
            lambda x: 1 if x == 'defaulted' else 0
        ).mean()
        expert_profit = expert_approved['actual_outcome'].apply(
            lambda x: x.get('profit', 0) if isinstance(x, dict) else 0
        ).sum()
        
        # 2. 模型决策的实际结果
        model_approved = merged[merged['model_decision'] == 'approve']
        model_default_rate = model_approved['actual_outcome'].apply(
            lambda x: 1 if x == 'defaulted' else 0
        ).mean()
        model_profit = model_approved['actual_outcome'].apply(
            lambda x: x.get('profit', 0) if isinstance(x, dict) else 0
        ).sum()
        
        # 3. 比较
        return {
            'expert_default_rate': expert_default_rate,
            'model_default_rate': model_default_rate,
            'expert_profit': expert_profit,
            'model_profit': model_profit,
            'profit_improvement': (model_profit - expert_profit) / expert_profit if expert_profit > 0 else 0,
            'is_better': model_profit > expert_profit and model_default_rate <= expert_default_rate * 1.1
        }
```

### 4.2 业务规则验证

```python
def validate_business_rules(self, decisions: pd.DataFrame, rules: List[Dict]):
    """
    验证决策是否符合业务规则
    
    Args:
        decisions: 决策数据框
        rules: 业务规则列表
    """
    violations = []
    
    for rule in rules:
        rule_type = rule['type']
        field = rule['field']
        operator = rule['operator']
        value = rule['value']
        
        if rule_type == 'threshold':
            if operator == '>=':
                violated = decisions[decisions[field] < value]
            elif operator == '<=':
                violated = decisions[decisions[field] > value]
            else:
                continue
            
            if len(violated) > 0:
                violations.append({
                    'rule': rule['description'],
                    'violation_count': len(violated),
                    'violation_rate': len(violated) / len(decisions)
                })
    
    total_violations = sum(v['violation_count'] for v in violations)
    violation_rate = total_violations / len(decisions)
    
    return {
        'violations': violations,
        'total_violations': total_violations,
        'violation_rate': violation_rate,
        'is_valid': violation_rate < 0.05  # 违规率低于5%
    }
```

### 4.3 逻辑一致性验证

```python
def validate_logical_consistency(self, decisions: pd.DataFrame):
    """
    验证决策的逻辑一致性
    
    例如：
    - 如果客户A的信用分 > 客户B的信用分，且其他条件相同
    - 那么客户A应该更容易获得批准
    """
    # 1. 排序一致性
    # 按信用分排序
    sorted_decisions = decisions.sort_values('credit_score', ascending=False)
    
    # 检查：信用分高的客户，审批率应该更高
    top_quartile = sorted_decisions.head(len(sorted_decisions) // 4)
    bottom_quartile = sorted_decisions.tail(len(sorted_decisions) // 4)
    
    top_approval_rate = (top_quartile['decision'] == 'approve').mean()
    bottom_approval_rate = (bottom_quartile['decision'] == 'approve').mean()
    
    is_consistent = top_approval_rate >= bottom_approval_rate
    
    # 2. 单调性检查
    # 对于相同特征的客户，利率应该与风险正相关
    risk_bins = np.percentile(decisions['default_probability'], [0, 25, 50, 75, 100])
    interest_rates = []
    
    for i in range(len(risk_bins) - 1):
        bin_decisions = decisions[
            (decisions['default_probability'] >= risk_bins[i]) &
            (decisions['default_probability'] < risk_bins[i+1])
        ]
        avg_rate = bin_decisions['interest_rate'].mean()
        interest_rates.append(avg_rate)
    
    # 检查利率是否随风险单调递增
    is_monotonic = all(interest_rates[i] <= interest_rates[i+1] 
                      for i in range(len(interest_rates) - 1))
    
    return {
        'top_quartile_approval_rate': top_approval_rate,
        'bottom_quartile_approval_rate': bottom_approval_rate,
        'is_consistent': is_consistent,
        'is_monotonic': is_monotonic,
        'is_valid': is_consistent and is_monotonic
    }
```

---

## 五、第三层：结果验证

### 5.1 回测验证

#### 5.1.1 历史数据回测

```python
class BacktestValidator:
    """回测验证器"""
    
    def __init__(self, historical_data: pd.DataFrame, model):
        self.historical = historical_data
        self.model = model
    
    def backtest(self, start_date: str, end_date: str):
        """
        使用历史数据进行回测
        
        Args:
            start_date: 回测开始日期
            end_date: 回测结束日期
        """
        # 筛选时间范围内的数据
        test_data = self.historical[
            (self.historical['application_date'] >= start_date) &
            (self.historical['application_date'] <= end_date)
        ]
        
        results = []
        
        for _, row in test_data.iterrows():
            # 使用模型进行决策（只使用申请时的信息）
            customer_state = self.extract_state_at_application(row)
            decision = self.model.predict(customer_state)
            
            # 获取实际结果
            actual_outcome = row['actual_outcome']
            
            results.append({
                'customer_id': row['customer_id'],
                'decision': decision,
                'actual_outcome': actual_outcome,
                'profit': self.calculate_profit(decision, actual_outcome),
                'defaulted': actual_outcome == 'defaulted'
            })
        
        results_df = pd.DataFrame(results)
        
        # 计算回测指标
        return {
            'total_cases': len(results_df),
            'approval_rate': (results_df['decision'] == 'approve').mean(),
            'default_rate': results_df[results_df['decision'] == 'approve']['defaulted'].mean(),
            'total_profit': results_df['profit'].sum(),
            'avg_profit_per_loan': results_df[results_df['decision'] == 'approve']['profit'].mean(),
            'roi': results_df['profit'].sum() / results_df[results_df['decision'] == 'approve']['loan_amount'].sum(),
            'results': results_df
        }
    
    def walk_forward_validation(self, train_periods: int = 12, test_periods: int = 3):
        """
        滚动窗口验证
        
        Args:
            train_periods: 训练期数（月）
            test_periods: 测试期数（月）
        """
        all_results = []
        
        # 按月滚动
        dates = sorted(self.historical['application_date'].unique())
        
        for i in range(len(dates) - train_periods - test_periods):
            # 训练期
            train_start = dates[i]
            train_end = dates[i + train_periods]
            train_data = self.historical[
                (self.historical['application_date'] >= train_start) &
                (self.historical['application_date'] < train_end)
            ]
            
            # 测试期
            test_start = dates[i + train_periods]
            test_end = dates[i + train_periods + test_periods]
            test_data = self.historical[
                (self.historical['application_date'] >= test_start) &
                (self.historical['application_date'] < test_end)
            ]
            
            # 在训练期上训练模型
            self.model.train(train_data)
            
            # 在测试期上测试
            test_result = self.backtest(test_start, test_end)
            test_result['train_period'] = f"{train_start} to {train_end}"
            test_result['test_period'] = f"{test_start} to {test_end}"
            
            all_results.append(test_result)
        
        # 汇总结果
        return {
            'period_results': all_results,
            'avg_default_rate': np.mean([r['default_rate'] for r in all_results]),
            'avg_profit': np.mean([r['total_profit'] for r in all_results]),
            'std_profit': np.std([r['total_profit'] for r in all_results]),
            'profit_stability': 1 - (np.std([r['total_profit'] for r in all_results]) / 
                                   np.mean([r['total_profit'] for r in all_results]))
        }
```

### 5.2 敏感性分析

```python
def sensitivity_analysis(self, base_scenario: Dict, variations: List[Dict]):
    """
    敏感性分析：测试不同场景下的表现
    
    Args:
        base_scenario: 基础场景
        variations: 场景变化列表
    """
    results = []
    
    for variation in variations:
        # 创建变化后的场景
        scenario = {**base_scenario, **variation}
        
        # 运行模拟
        simulation_result = self.run_simulation(scenario)
        
        results.append({
            'scenario': scenario,
            'result': simulation_result,
            'variation': variation
        })
    
    # 分析结果
    return {
        'results': results,
        'sensitivity': self.calculate_sensitivity(results),
        'robustness': self.assess_robustness(results)
    }
```

### 5.3 基准对比

```python
def benchmark_comparison(self, model_results: Dict, benchmarks: Dict[str, Dict]):
    """
    与多个基准对比
    
    Args:
        model_results: 模型结果
        benchmarks: 基准结果字典
            {
                'expert': {...},
                'rule_based': {...},
                'simple_model': {...}
            }
    """
    comparison = {}
    
    for benchmark_name, benchmark_result in benchmarks.items():
        comparison[benchmark_name] = {
            'profit_ratio': model_results['total_profit'] / benchmark_result['total_profit'],
            'default_rate_diff': model_results['default_rate'] - benchmark_result['default_rate'],
            'approval_rate_diff': model_results['approval_rate'] - benchmark_result['approval_rate'],
            'is_better': (
                model_results['total_profit'] > benchmark_result['total_profit'] and
                model_results['default_rate'] <= benchmark_result['default_rate'] * 1.1
            )
        }
    
    return comparison
```

---

## 六、综合验证流程

### 6.1 完整验证流程

```python
class ComprehensiveValidator:
    """综合验证器"""
    
    def __init__(self, historical_data, simulated_data, model):
        self.env_validator = EnvironmentValidator(historical_data, simulated_data)
        self.decision_validator = DecisionValidator(historical_data, simulated_data)
        self.backtest_validator = BacktestValidator(historical_data, model)
    
    def comprehensive_validation(self):
        """综合验证"""
        results = {}
        
        # 1. 环境验证
        print("1. Validating environment...")
        env_results = self.env_validator.validate_all_fields([
            'age', 'monthly_income', 'credit_score', 'debt_ratio'
        ])
        results['environment'] = env_results
        
        # 2. 决策验证
        print("2. Validating decisions...")
        decision_results = self.decision_validator.validate_decision_consistency()
        results['decisions'] = decision_results
        
        # 3. 回测验证
        print("3. Running backtest...")
        backtest_results = self.backtest_validator.walk_forward_validation()
        results['backtest'] = backtest_results
        
        # 4. 综合评估
        print("4. Overall assessment...")
        results['overall'] = self.assess_overall(results)
        
        return results
    
    def assess_overall(self, results: Dict) -> Dict:
        """综合评估"""
        # 环境验证通过
        env_valid = all(r['valid'] for r in results['environment'].values())
        
        # 决策一致性
        decision_valid = results['decisions']['is_acceptable']
        
        # 回测稳定性
        backtest_stable = results['backtest']['profit_stability'] > 0.8
        
        # 综合判断
        is_valid = env_valid and decision_valid and backtest_stable
        
        return {
            'environment_valid': env_valid,
            'decision_valid': decision_valid,
            'backtest_stable': backtest_stable,
            'overall_valid': is_valid,
            'recommendation': 'PASS' if is_valid else 'FAIL'
        }
```

---

## 七、验证指标体系

### 7.1 核心指标

```python
VALIDATION_METRICS = {
    # 环境验证指标
    'environment': {
        'distribution_ks_pvalue': {'threshold': 0.05, 'direction': '>'},
        'mean_diff': {'threshold': 0.05, 'direction': '<'},
        'default_rate_diff': {'threshold': 0.02, 'direction': '<'}
    },
    
    # 决策验证指标
    'decision': {
        'agreement_rate': {'threshold': 0.7, 'direction': '>'},
        'violation_rate': {'threshold': 0.05, 'direction': '<'},
        'logical_consistency': {'threshold': True, 'direction': '=='}
    },
    
    # 结果验证指标
    'result': {
        'profit_improvement': {'threshold': 0.0, 'direction': '>'},
        'default_rate_control': {'threshold': 0.05, 'direction': '<'},
        'profit_stability': {'threshold': 0.8, 'direction': '>'}
    }
}
```

### 7.2 验证报告生成

```python
def generate_validation_report(self, results: Dict) -> str:
    """生成验证报告"""
    report = []
    report.append("=" * 80)
    report.append("放贷决策验证报告")
    report.append("=" * 80)
    report.append("")
    
    # 环境验证
    report.append("一、环境验证")
    report.append("-" * 80)
    env_results = results['environment']
    for field, result in env_results.items():
        status = "✓ PASS" if result['valid'] else "✗ FAIL"
        report.append(f"{field}: {status}")
        if not result['valid']:
            report.append(f"  详情: {result['statistics']}")
    report.append("")
    
    # 决策验证
    report.append("二、决策验证")
    report.append("-" * 80)
    decision_results = results['decisions']
    report.append(f"与专家决策一致性: {decision_results['agreement_rate']:.2%}")
    report.append(f"状态: {'✓ PASS' if decision_results['is_acceptable'] else '✗ FAIL'}")
    report.append("")
    
    # 回测验证
    report.append("三、回测验证")
    report.append("-" * 80)
    backtest_results = results['backtest']
    report.append(f"平均违约率: {backtest_results['avg_default_rate']:.2%}")
    report.append(f"平均利润: {backtest_results['avg_profit']:.2f}")
    report.append(f"利润稳定性: {backtest_results['profit_stability']:.2%}")
    report.append("")
    
    # 综合评估
    report.append("四、综合评估")
    report.append("-" * 80)
    overall = results['overall']
    report.append(f"环境验证: {'✓' if overall['environment_valid'] else '✗'}")
    report.append(f"决策验证: {'✓' if overall['decision_valid'] else '✗'}")
    report.append(f"回测稳定: {'✓' if overall['backtest_stable'] else '✗'}")
    report.append(f"")
    report.append(f"最终结论: {overall['recommendation']}")
    report.append("=" * 80)
    
    return "\n".join(report)
```

---

## 八、实际应用示例

### 8.1 使用示例

```python
# 1. 准备数据
historical_data = load_historical_loans()
simulated_data = generate_simulation_data(num_samples=10000)

# 2. 训练模型
model = train_loan_approval_model(historical_data)

# 3. 运行验证
validator = ComprehensiveValidator(historical_data, simulated_data, model)
results = validator.comprehensive_validation()

# 4. 生成报告
report = validator.generate_validation_report(results)
print(report)

# 5. 保存结果
save_validation_results(results, 'validation_results.json')
```

### 8.2 持续监控

```python
class ContinuousMonitor:
    """持续监控器"""
    
    def __init__(self, model, validation_thresholds: Dict):
        self.model = model
        self.thresholds = validation_thresholds
        self.monitoring_history = []
    
    def monitor(self, new_data: pd.DataFrame):
        """监控新数据"""
        # 运行验证
        results = self.run_validation(new_data)
        
        # 检查是否超过阈值
        alerts = []
        for metric, threshold in self.thresholds.items():
            if results[metric] > threshold:
                alerts.append({
                    'metric': metric,
                    'value': results[metric],
                    'threshold': threshold,
                    'status': 'ALERT'
                })
        
        # 记录历史
        self.monitoring_history.append({
            'timestamp': pd.Timestamp.now(),
            'results': results,
            'alerts': alerts
        })
        
        return {
            'results': results,
            'alerts': alerts,
            'status': 'OK' if len(alerts) == 0 else 'ALERT'
        }
```

---

## 九、总结

### 9.1 验证要点

1. **环境验证**：确保模拟环境真实反映现实
2. **决策验证**：确保决策合理、一致、符合规则
3. **结果验证**：确保结果可靠、稳定、优于基准

### 9.2 验证标准

- ✅ **环境分布**：模拟数据分布与历史数据一致（KS检验p>0.05）
- ✅ **决策一致性**：与专家决策一致性 > 70%
- ✅ **规则合规**：违规率 < 5%
- ✅ **逻辑一致**：决策逻辑符合业务常识
- ✅ **回测稳定**：滚动窗口验证利润稳定性 > 80%
- ✅ **优于基准**：利润优于基准，违约率可控

### 9.3 验证流程

```
数据准备
    ↓
环境验证（分布、因果关系）
    ↓
决策验证（一致性、规则、逻辑）
    ↓
结果验证（回测、敏感性、基准对比）
    ↓
综合评估
    ↓
生成报告
```

### 9.4 注意事项

1. **不要过度拟合**：验证集应该独立于训练集
2. **考虑时间因素**：使用滚动窗口验证，避免未来信息泄露
3. **多维度验证**：不仅看利润，还要看风险、合规性
4. **持续监控**：部署后持续监控，及时发现异常
5. **定期重验证**：随着数据变化，定期重新验证

